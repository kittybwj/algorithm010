## 第八周学习总结
### 第十六课：位运算

#### 一、位运算符

* 左移： <<  (0011 => 1011)
* 右移： >>  (0110 => 0011)
* 按位或： |  （0011 | 1011 => 1011）
* 按位与： &  （0011 | 1011 => 0011）
* 按位取反：  ~  (0011 => 1100)
* 按位异或：  ^  (0011 | 1011 => 1000)

#### 二、异或

* 相同为0，不同为1
* x ^ 0 = x
* x ^ 1s(全1) = ~x
* x ^ (-x) = 1s
* x ^ x = 0

#### 三、指定位置的位运算

* 将x最右边的n位清零： x & (1  << n)
* 获取x第n位的值：（x>>n）&1
* 获取x的第n位的幂值：x & （1 << n）

#### 四、实战位运算要点（重要）

1、判断奇偶：

* 奇：x%2==1   => x & 1 == 1  
* 偶：x%2==0   => x & 1 == 0

2、 x >> 1 => x/2

3、清零最低位的1 : x = x & (x-1) 

4、得到最低位的1：x & -x (-x：所有位置取反+1)

5、x & ~x = 0


### 第十七课：布隆过滤器和LRU缓存

#### 一、布隆过滤器（Bloom Filter）

1、原理及特点

* 一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中，但是没有存储元素的其他信息。
* 优点：空间效率和查询时间都远远超过一般算法
* 缺点：是一种模糊的查询方式，有一定的误识别率和删除困难
* 结论：一个元素在布隆过滤器里面查询，如果查询不到，一定是不在，如果是存在，则可能存在。

2、现实应用

* 比特币网络
* 分布式系统
* Redis缓存
* 垃圾邮件、评论过滤等

#### 二、LRU Catch

1、缓存的两个要素：大小、替换策略

2、数据结构：Hash Table + Linked List

* 查询：O(1)
* 修改、更新：O(1)

3、最近被使用的元素永远在最上面

4、替换策略

* LRU：least recently used 最近最少被使用的淘汰
* LFU：least frequently used 最近使用频率最低的被淘汰

### 第十八课：排序算法

一、比较类排序

1、时间复杂度：O(n^2)

* 选择排序：遍历找到最小值，放到起始位置
* 插入排序：从前到后逐步构建有序数量
* 冒泡排序：嵌套循环，相邻元素如果逆序，则交换，会把最大的数放到最后。

2、时间复杂度：O(nlogn) （重要！面试常考！会手写！）

* 快速排序：去一个标杆，小元素放左侧，大元素放右侧，然后依次对左右两边的数组进行快排。（不申请新的数组空间）
* 归并排序（分治）：一分为二，分别归并，左右两边都排好序，再合并。（需要创建一个中间数组）
* 堆排序：堆插入O(logN) ，取最大值或最小值O(1)。元素依次插入建立小顶堆，一次取堆顶元素并删除。

**归并和快排有相似性，但步骤顺序相反。**

二、非比较类排序

* 计数排序
* 桶排序
* 基数排序